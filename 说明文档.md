# 1 实验要求

参考论文 [https://eprint.iacr.org/2019/723.pdf](https://eprint.iacr.org/2019/723.pdf) 的 section 3.1 ，也即 Figure 2 中展示的协议，尝试实现该协议，（编程语言不限）。

# 2 协议目标

给定：
- **P1** 持有集合 $V = \{v_i\}$
- **P2** 持有带权集合 $W = \{(w_j, t_j)\}$

协议输出：
- 交集大小 $C = |V \cap W|$
- 交集权重和 $S = \sum_{w_j \in V \cap W} t_j$

同时保证：
- P1 不知道 P2 的非交集元素
- P2 不知道 P1 的集合内容

# 3 数学推导与协议表示

## 3.1 群与映射
- 选取满足 DDH 假设的循环群 $G$，阶为 $q$，生成元为 $g$。
- 定义哈希到群的映射： $H(x) = g^{h(x)} \bmod p,\quad h(x) = \text{SHA256}(x) \bmod q$

## 3.2 Paillier 加密
- 公私钥对 $(pk, sk)$，满足加法同态： $Enc(m_1) \cdot Enc(m_2) = Enc(m_1 + m_2)$

## 3.3 协议流程（Figure 2）

1. **Round 1**（P1→P2）  
   P1 选择 $k_1 \in \mathbb{Z}_q^\ast$  
   发送乱序集合： $X_i = H(v_i)^{k_1}$
 
2. **Round 2**（P2→P1）  
   P2 选择 $k_2 \in \mathbb{Z}_q^\ast$  
   计算： $Z_i = X_i^{k_2} = H(v_i)^{k_1 k_2}$
   对自身集合： $Y_j = H(w_j)^{k_2},\quad C_j = Enc(t_j)$
   将乱序 $Z$、乱序 $(Y_j, C_j)$ 及 $pk$ 发送给 P1。

3. **Round 3**（P1→P2）  
   P1 计算： $\tilde{Y}_j = Y_j^{k_1} = H(w_j)^{k_1 k_2}$
   
   若 Ỹⱼ ∈ Z，则将  $C_j$ 纳入同态乘积： $C^\star = \prod_{j:\tilde{Y}_j \in Z} C_j$ 
   无交集时取 $Enc(0)$ 。  
   对 $C^\star$ 进行重随机化后发送给 P2。

5. **输出结果**  
   P2 解密： $S = Dec(C^\star)$
   P1 统计匹配次数得 $C$。

# 4 实现思路

- **群构造**：使用安全素数 $p=2q+1$，取 $Z_p^\ast$ 的阶 $q$ 子群。
- **哈希到群**：SHA256 再取模 $q$，指数化生成群元素。
- **Paillier 实现**：标准 $g = n + 1$ 参数化，支持加法同态、常数倍同态、重随机化。
- **安全性措施**：
  - 列表乱序，隐藏元素对应关系
  - 重随机化 Paillier 密文，隐藏访问模式
- **演示数据**：  
  - P1 集合：`{id_10, id_20, id_30, id_40, id_50, id_60, id_70}`  
  - P2 集合：`{(id_5, 11), (id_15, 22), (id_20, 33), (id_25, 44), (id_30, 55), (id_35, 66)}`  
  - 交集为 `{id_20, id_30}`，权重和 $33 + 55 = 88$。  

# 5 运行结果：
```
交集大小 C = 2
交集求和 S = 88
```
